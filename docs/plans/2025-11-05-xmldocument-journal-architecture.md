# XMLDocument and Journal Architecture - Design Brainstorm

**Date**: 2025-11-05
**Status**: Design Complete
**Type**: Architecture Design

## Executive Summary

This document captures the complete architectural design for introducing Pydantic data models to replace raw XML handling throughout the D&D module processing pipeline. The key insight is creating two distinct layers:

1. **XMLDocument** - Immutable record of what Gemini generated (pure XML representation)
2. **Journal** - Mutable working representation with semantic hierarchy and rich linking features

This separation allows clean boundaries: XML is a serialization format for storage/debugging, Pydantic models are the working format in code.

---

## Problem Statement

### Current State Issues

Currently, XML is generated by `pdf_to_xml.py` and used directly by downstream processes:
- Raw XML strings passed between functions
- XML parsing happens multiple times (performance cost)
- No type safety - downstream code uses XPath queries
- Hard to validate structure beyond "well-formed XML"
- Adding new features (images, links) requires changing multiple parsers

### Goals

1. **Single source of truth**: Parse XML once at the boundary
2. **Type safety**: Rest of codebase gets IntelliSense, type checking
3. **Fail fast**: Invalid XML caught immediately after generation
4. **Easy refactoring**: Change model, all consumers update automatically
5. **Rich features**: Support image insertion, entity linking, dice rolls, cross-references

---

## Design Questions Explored

### 1. XMLDocument Structure: Mirror vs. Semantic

**Question**: Should XMLDocument mirror XML structure exactly or restructure semantically?

**Options**:
- **A (Direct Mirror)**: Preserve page boundaries, content exactly as in XML
- **B (Semantic Restructuring)**: Flatten pages, organize by sections

**Decision**: **Option A** for XMLDocument
- Preserves PDF correlation (debugging, tracing back to source)
- 1:1 mapping with XML makes parsing straightforward
- Page boundaries useful for image detection (maps appear on specific pages)

### 2. Image Placeholder Strategy

**Question**: How should images be represented in the data model?

**Options**:
- **A (Inline placeholders)**: ImageRef as content type, mixed with paragraphs
- **B (Separate registry)**: Images tracked in dict, referenced by key

**Decision**: **Hybrid approach**
- ImageRef inline in content stream (preserves Gemini's placement)
- Registry in Journal for metadata (type, description, final placement)
- Allows repositioning without restructuring content

**Image Registry Keys**: Format `"page_{num}_{position}_{type}"`
- Example: `"page_5_top_battle_map"`
- Predictable, human-readable, includes context

### 3. Journal Transformation Strategy

**Question**: Should Journal transform content or augment it?

**Options**:
- **A (Transform)**: Rewrite paragraphs to add @UUID links, modify in place
- **B (Augment)**: Keep original content, track links separately

**Decision**: **Option A (Transform with iteration)**
- Better for FoundryVTT HTML export (links must be in text)
- Iterative transformations: `add_chapter_links() → add_npc_links() → add_spell_links()` etc.
- Each function checks individual phrases before linking (not whole paragraphs)
- **Critical**: Check `is_already_linked()` per-phrase to avoid nested/conflicting links

**Link Conflict Prevention**:
```python
# WRONG: Skip whole paragraph if any link exists
if has_existing_links(paragraph):
    skip_entire_paragraph()

# RIGHT: Check each phrase individually
for npc_name in find_matches(paragraph):
    if not is_already_linked(npc_name_span, paragraph):
        insert_link(npc_name_span)
```

### 4. StatBlock Storage

**Question**: Should XMLDocument parse stat blocks or store raw?

**Options**:
- **A**: XMLDocument parses to ParsedStatBlock immediately
- **B**: XMLDocument stores raw XML, Journal parses later

**Decision**: **Option B**
- XMLDocument is pure record (no business logic)
- Parsing belongs in Journal layer (with game context)
- Raw XML sent to existing `parse_stat_blocks.py`

```python
class StatBlockRaw(BaseModel):
    xml_element: str  # Full <stat_block>...</stat_block>
```

### 5. Validation Strategy

**Question**: How should XMLDocument handle malformed XML?

**Options**:
- **A (Fail fast)**: Raise ValidationError immediately
- **B (Degrade gracefully)**: Parse partial data, track errors

**Decision**: **Option A (Fail fast)**
- `pdf_to_xml.py` already has retry/correction logic
- Validation at XMLDocument layer ensures clean data
- Errors caught early, not propagated downstream

### 6. Journal Structure: Pages vs. Semantic

**Question**: Should Journal preserve PDF page boundaries?

**Options**:
- **A**: Keep pages (like XMLDocument)
- **B**: Flatten to sections/chapters
- **C**: FoundryVTT structure (journal pages = chapters)

**Decision**: **Option B (Semantic hierarchy)**
- Flattens page boundaries
- Organized by: Chapter → Section → Subsection → Subsubsection → Content
- Matches D&D module semantic structure
- Better for cross-references ("Chapter 2 → Area 1")

**XML Structure** (from actual files):
```xml
<Chapter_01_Introduction>
  <page number="1">
    <chapter_title>INTRODUCTION</chapter_title>
    <section>RUNNING THE ADVENTURE</section>
    <p>Lost Mine of Phandelver is...</p>
    <section>THE DUNGEON MASTER</section>
    <boxed_text>
      <subsection>RULES TO GAME BY</subsection>
      <p>As the Dungeon Master...</p>
    </boxed_text>
  </page>
</Chapter_01_Introduction>
```

**Hierarchy**: `chapter_title` → `section` → `subsection` → `subsubsection`

### 7. Image Registry Persistence

**Question**: When images are extracted later, how to persist file paths?

**Options**:
- **A (Mutable model)**: XMLDocument allows mutation, update in place
- **B (Separate mapping file)**: Keep XMLDocument immutable, track paths separately
- **C (Rebuild)**: Reconstruct XMLDocument with updated paths

**Decision**: **Option B (Separate mapping file)**
- XMLDocument stays immutable (clean record)
- `image_mapping.json`: `{registry_key: file_path}`
- Fits existing architecture (timestamped runs with stage outputs)
- Extraction can fail → missing keys = graceful degradation

**File Structure**:
```
output/runs/20241105_143022/
├── documents/
│   └── 01_Introduction.xml      # XMLDocument serialized
├── images/                       # Extracted image files
│   ├── page_5_battle_map.png
│   └── scene_chapter2_area1.png
└── image_mapping.json            # {"page_5_top_battle_map": "images/..."}
```

### 8. Image Ownership

**Question**: Should XMLDocument or Journal own the image registry?

**Decision**: **Journal owns it**
- XMLDocument is pure XML record (only has ImageRef placeholders)
- Journal extracts ImageRef into registry during initialization
- Journal can add/edit/reposition images (scene artwork, custom images)
- XMLDocument never changes after creation

**Rationale**:
- Separates "what Gemini saw" (XMLDocument) from "what we want to render" (Journal)
- Adding scene artwork shouldn't modify the XML record
- Image processing can reposition without touching source data

### 9. Adding New Images Post-Creation

**Question**: How to insert scene artwork or custom images after Journal is created?

**Decision**: Journal has image manipulation methods
```python
journal.add_image(key, metadata)  # New images (scene artwork)
journal.reposition_image(key, content_id)  # Move existing images
journal.remove_image(key)  # Delete images
```

**Placement**: Uses content IDs
```python
ImageMetadata(
    insert_before_content_id="chapter_2_section_3_content_5"
)
```

**Content IDs**: Every content element gets unique ID during parsing
- Format: `"page_{num}_content_{idx}"` (XMLDocument) or `"chapter_{n}_section_{m}_content_{idx}"` (Journal)
- Enables precise positioning without restructuring content

### 10. Missing Context Handling

**Question**: What if entity links reference non-existent actors/spells/items?

**Options**:
- **A**: Skip silently (only link what exists)
- **B**: Create placeholder/broken links
- **C**: Fail fast (raise error)

**Decision**: **Option A (Skip silently)**
- Graceful degradation
- Matches "fail fast" only for XML validation
- Partial context is useful (link what's available)

---

## Final Architecture

### Core Models

#### XMLDocument (Immutable Record)

```python
class XMLDocument(BaseModel):
    """Pure XML record - immutable representation of generated XML"""
    model_config = ConfigDict(frozen=True)

    title: str
    pages: List[Page]  # Preserves PDF structure

    @classmethod
    def from_xml(cls, xml_string: str) -> 'XMLDocument':
        """Fail-fast parsing. Raises ValidationError on any issues."""
        root = ET.fromstring(xml_string)
        # ... strict parsing
        return cls(...)

    def to_xml(self) -> str:
        """Serialize back to XML string"""
        ...

class Page(BaseModel):
    number: int
    content: List[Content]

class Content(BaseModel):
    id: str  # "page_5_content_3"
    type: Literal[
        "paragraph", "section", "subsection", "subsubsection",
        "chapter_title", "stat_block", "table", "boxed_text",
        "list", "definition_list", "image_ref"
    ]
    data: Union[str, StatBlockRaw, Table, List, DefinitionList, ImageRef, ...]

class StatBlockRaw(BaseModel):
    """Raw XML element for parse_stat_blocks.py"""
    xml_element: str  # Complete <stat_block>...</stat_block>

class ImageRef(BaseModel):
    """Placeholder from Gemini - inline in content stream"""
    key: str  # "page_5_top_battle_map"

class Table(BaseModel):
    rows: List[TableRow]

class TableRow(BaseModel):
    cells: List[str]

class List(BaseModel):
    items: List[str]

class DefinitionList(BaseModel):
    items: List[DefinitionItem]

class DefinitionItem(BaseModel):
    term: str
    definition: str
```

#### Journal (Semantic Working Representation)

```python
class Journal(BaseModel):
    """Mutable working representation with semantic hierarchy"""
    source: XMLDocument  # Reference to original
    chapters: List[Chapter]  # Semantic hierarchy
    image_registry: Dict[str, ImageMetadata]  # Journal owns this

    @classmethod
    def from_xml_document(cls, doc: XMLDocument, context: Optional[GameContext] = None):
        # 1. Build semantic hierarchy (flatten pages)
        journal = cls._build_hierarchy(doc)

        # 2. Extract ImageRef placeholders into registry
        journal.image_registry = cls._extract_image_refs(doc)

        # 3. Iterative transformations (if context provided)
        if context:
            journal = add_chapter_links(journal, context)
            journal = add_npc_links(journal, context.actors)
            journal = add_spell_links(journal, context.spell_cache)
            journal = add_item_links(journal, context.items)
            journal = add_dice_rolls(journal)

        # 4. Resolve image placements
        journal = resolve_image_links(journal)

        return journal

    # Image manipulation
    def add_image(self, key: str, metadata: ImageMetadata):
        """Add new image (scene artwork, custom, etc.)"""
        self.image_registry[key] = metadata

    def reposition_image(self, key: str, new_content_id: str):
        """Move image to different location"""
        self.image_registry[key].insert_before_content_id = new_content_id

    def remove_image(self, key: str):
        """Remove image from registry"""
        del self.image_registry[key]

    # Export methods
    def to_foundry_html(self, image_mapping: Dict[str, str]) -> str:
        """FoundryVTT HTML with @UUID links"""
        ...

    def to_html(self, image_mapping: Dict[str, str]) -> str:
        """Generic HTML export"""
        ...

    def to_markdown(self, image_mapping: Dict[str, str]) -> str:
        """Markdown export"""
        ...

class Chapter(BaseModel):
    id: str  # "chapter_1"
    title: str  # From <chapter_title> or filename
    sections: List[Section]

class Section(BaseModel):
    id: str  # "chapter_1_section_2"
    heading: str  # "THE DUNGEON MASTER"
    content: List[Content]  # Paragraphs, tables, boxed_text, image_refs
    subsections: List[Subsection]

class Subsection(BaseModel):
    id: str  # "chapter_1_section_2_subsection_1"
    heading: str
    content: List[Content]
    subsubsections: List[Subsubsection]

class Subsubsection(BaseModel):
    id: str
    heading: str
    content: List[Content]

class ImageMetadata(BaseModel):
    """Image metadata - owned by Journal, not XMLDocument"""
    page_num: Optional[int]  # None for generated images
    type: Literal["battle_map", "navigation_map", "scene_illustration", "generated_scene"]
    position: str  # Descriptive: "top", "middle", "bottom", "full_page"
    description: Optional[str]
    insert_before_content_id: Optional[str]  # Override initial placement
    source: Literal["gemini_detected", "scene_generated", "manual"]

class GameContext(BaseModel):
    """External data needed for link generation"""
    actors: List[Actor]
    spell_cache: SpellCache
    items: List[Item]
```

### Transformation Patterns

#### Link Addition Pattern

```python
def add_npc_links(journal: Journal, actors: List[Actor]) -> Journal:
    """
    Add @UUID links for NPCs.
    Checks each phrase individually to avoid nested/conflicting links.
    """
    for chapter in journal.chapters:
        for section in get_all_sections_recursive(chapter):
            for content in section.content:
                if content.type == "paragraph":
                    for actor in actors:
                        # Find all occurrences of actor.name
                        for match in find_all_occurrences(content.data, actor.name):
                            # Check if THIS specific occurrence is already linked
                            if not is_already_linked(match.span, content.data):
                                content.data = insert_link(
                                    content.data,
                                    match.span,
                                    f"@UUID[Actor.{actor.uuid}]{{{actor.name}}}"
                                )
    return journal

def is_already_linked(span: Tuple[int, int], text: str) -> bool:
    """
    Check if text at span is inside @UUID{...} or <a href=...> etc.
    Looks backwards for link start, forwards for link end.
    """
    start, end = span
    # Implementation: regex or simple string scanning
    ...
```

#### Image Workflow

```python
# 1. XML Generation (pdf_to_xml.py)
# - Gemini detects images, inserts <image_ref> placeholders
# - XMLDocument parsed with ImageRef inline

xml_doc = XMLDocument.from_xml(xml_string)
# xml_doc.pages[4].content = [
#     Section(...),
#     Paragraph(...),
#     ImageRef(key="page_5_top_battle_map"),  # Gemini's placement
#     Paragraph(...)
# ]

# 2. Create Journal (extracts ImageRef into registry)
journal = Journal.from_xml_document(xml_doc)
# journal.image_registry = {
#     "page_5_top_battle_map": ImageMetadata(
#         page_num=5,
#         type="battle_map",
#         position="top",
#         source="gemini_detected",
#         insert_before_content_id="chapter_2_section_3_content_2"  # From ImageRef position
#     )
# }

# 3. Image Extraction (separate process)
def extract_and_map_images(journal: Journal, run_dir: str):
    """
    Extract images from PDF based on registry metadata.
    Saves mapping file with registry_key -> file_path.
    """
    mapping = {}
    for key, metadata in journal.image_registry.items():
        if metadata.source == "gemini_detected":
            # Extract from PDF page
            extracted_path = extract_image_from_pdf(
                metadata.page_num,
                metadata.type,
                metadata.position
            )
            if extracted_path:
                mapping[key] = extracted_path

    save_json(mapping, f"{run_dir}/image_mapping.json")
    return mapping

# 4. Add Scene Artwork (modifies Journal only)
def add_scene_artwork(journal: Journal, scenes: List[Scene], run_dir: str):
    """
    Generate scene artwork and add to Journal registry.
    Updates image_mapping.json.
    """
    mapping = load_json(f"{run_dir}/image_mapping.json")

    for scene in scenes:
        key = f"scene_{scene.chapter}_{sanitize(scene.name)}"

        # Add to Journal registry
        journal.add_image(key, ImageMetadata(
            page_num=None,  # Not from PDF
            type="generated_scene",
            source="scene_generated",
            insert_before_content_id=find_section_id(scene.section_path, journal)
        ))

        # Generate image
        image_path = generate_scene_image(scene, run_dir)
        mapping[key] = image_path

    save_json(mapping, f"{run_dir}/image_mapping.json")

# 5. Reposition Images (if needed)
# Image processing analyzes maps and repositions
def smart_reposition_images(journal: Journal):
    """
    Analyze extracted images and determine better placement.
    """
    for key, metadata in journal.image_registry.items():
        if metadata.type == "battle_map":
            # Find best section for this map
            best_content_id = analyze_map_and_find_section(key, journal)
            journal.reposition_image(key, best_content_id)

# 6. Render Journal
def render_journal(journal: Journal, image_mapping: Dict[str, str]) -> str:
    """
    Generate HTML with images inserted at registry positions.
    """
    html = ""
    for chapter in journal.chapters:
        for section in get_all_sections_flat(chapter):
            for content in section.content:
                # Insert images BEFORE this content
                for key, metadata in journal.image_registry.items():
                    if metadata.insert_before_content_id == content.id:
                        if key in image_mapping:
                            html += f'<img src="{image_mapping[key]}" alt="{metadata.description}" />'

                # Render content (skip ImageRef - now in registry)
                if content.type != "image_ref":
                    html += render_content(content)
    return html
```

---

## Implementation Notes

### Content ID Generation

**XMLDocument** (page-based):
```python
def generate_content_id(page_num: int, content_idx: int) -> str:
    return f"page_{page_num}_content_{content_idx}"
```

**Journal** (semantic hierarchy):
```python
def generate_content_id(chapter_idx: int, section_path: List[int], content_idx: int) -> str:
    # section_path = [2, 1] means section 2, subsection 1
    path_str = "_".join([f"s{i}" for i in section_path])
    return f"chapter_{chapter_idx}_{path_str}_content_{content_idx}"
    # Example: "chapter_1_s2_s1_content_5"
```

### Hierarchy Flattening

```python
def _build_hierarchy(doc: XMLDocument) -> List[Chapter]:
    """
    Flatten XMLDocument.pages into Journal.chapters.
    Sections can span multiple pages.
    """
    chapters = []
    current_chapter = None
    current_section = None
    current_subsection = None

    for page in doc.pages:
        for content in page.content:
            if content.type == "chapter_title":
                # Start new chapter
                current_chapter = Chapter(title=content.data, sections=[])
                chapters.append(current_chapter)

            elif content.type == "section":
                # Start new section
                current_section = Section(heading=content.data, content=[], subsections=[])
                current_chapter.sections.append(current_section)
                current_subsection = None  # Reset subsection

            elif content.type == "subsection":
                # Start new subsection
                current_subsection = Subsection(heading=content.data, content=[], subsubsections=[])
                current_section.subsections.append(current_subsection)

            elif content.type == "subsubsection":
                # Start new subsubsection
                subsubsection = Subsubsection(heading=content.data, content=[])
                current_subsection.subsubsections.append(subsubsection)

            else:
                # Add to current container
                if current_subsection:
                    # Check if in subsubsection
                    if current_subsection.subsubsections:
                        current_subsection.subsubsections[-1].content.append(content)
                    else:
                        current_subsection.content.append(content)
                elif current_section:
                    current_section.content.append(content)
                else:
                    # Top-level content (rare)
                    pass

    return chapters
```

### Export Implementations

```python
def to_foundry_html(journal: Journal, image_mapping: Dict[str, str]) -> str:
    """
    FoundryVTT HTML with:
    - @UUID[Actor.xyz]{NPC Name} links
    - @UUID[Item.abc]{Spell Name} links
    - [[/roll 1d20]] dice roll buttons
    - <img> tags for images
    """
    html = ""
    for chapter in journal.chapters:
        html += f"<h1>{chapter.title}</h1>"
        for section in chapter.sections:
            html += render_section(section, image_mapping, journal.image_registry, format="foundry")
    return html

def to_html(journal: Journal, image_mapping: Dict[str, str]) -> str:
    """
    Generic HTML with:
    - <a href> links for NPCs/spells
    - Plain text for dice notation
    - <img> tags for images
    """
    html = ""
    for chapter in journal.chapters:
        html += f"<h1>{chapter.title}</h1>"
        for section in chapter.sections:
            html += render_section(section, image_mapping, journal.image_registry, format="html")
    return html

def to_markdown(journal: Journal, image_mapping: Dict[str, str]) -> str:
    """
    Markdown with:
    - [NPC Name](#npc-anchor) links
    - Plain text for spells/dice
    - ![alt](path) for images
    """
    md = ""
    for chapter in journal.chapters:
        md += f"# {chapter.title}\n\n"
        for section in chapter.sections:
            md += render_section(section, image_mapping, journal.image_registry, format="markdown")
    return md
```

---

## Migration Strategy

### Phase 1: Create Models (Non-Breaking)

1. Create `src/models/xml_document.py` with XMLDocument classes
2. Create `src/models/journal.py` with Journal classes
3. Add tests for parsing existing XML files
4. No changes to existing code yet

### Phase 2: Update pdf_to_xml.py (Minimal Change)

1. At end of `process_chapter()`, parse to XMLDocument
2. Validate with `XMLDocument.from_xml()`
3. Return both XML string and XMLDocument
4. Downstream can use either (transition period)

```python
def process_chapter(pdf_path: str, output_xml_path: str, base_log_dir: str):
    # ... existing code ...

    # NEW: Parse to model for validation
    try:
        xml_doc = XMLDocument.from_xml(final_xml_content)
        logger.info("XMLDocument validation passed")
    except ValidationError as e:
        logger.error(f"XMLDocument validation failed: {e}")
        # Still save XML for debugging

    with open(output_xml_path, "w") as f:
        f.write(final_xml_content)

    return page_errors
```

### Phase 3: Update Downstream (Incremental)

1. `parse_stat_blocks.py`: Accept XMLDocument, extract stat blocks from model
2. `upload_to_foundry.py`: Accept XMLDocument, create Journal, export HTML
3. `full_pipeline.py`: Pass XMLDocument between stages
4. Deprecate XML string passing

### Phase 4: Add Image Support

1. Update `valid_xml_tags.py` to include `image_ref`
2. Update `pdf_to_xml.py` prompt to detect major images
3. Create `extract_and_map_images.py` script
4. Update Journal export to render images

### Phase 5: Add Link Features

1. Implement `add_npc_links()` function
2. Implement `add_spell_links()` function
3. Implement `add_item_links()` function
4. Implement `add_dice_rolls()` function
5. Update `full_pipeline.py` to run link generation

---

## Testing Strategy

### Unit Tests

```python
def test_xmldocument_from_xml():
    """Test XMLDocument parsing"""
    xml_string = """
    <Chapter_01_Introduction>
      <page number="1">
        <section>Test Section</section>
        <p>Test paragraph</p>
      </page>
    </Chapter_01_Introduction>
    """
    doc = XMLDocument.from_xml(xml_string)
    assert doc.title == "Chapter_01_Introduction"
    assert len(doc.pages) == 1
    assert doc.pages[0].number == 1

def test_journal_hierarchy():
    """Test Journal flattens pages into sections"""
    doc = XMLDocument.from_xml(sample_xml)
    journal = Journal.from_xml_document(doc)
    assert len(journal.chapters) == 1
    assert journal.chapters[0].title == "INTRODUCTION"

def test_add_npc_links():
    """Test NPC linking doesn't double-link"""
    journal = create_test_journal()
    actors = [Actor(name="Gundren", uuid="abc123")]

    journal = add_npc_links(journal, actors)
    # First occurrence should be linked
    assert "@UUID[Actor.abc123]{Gundren}" in journal.chapters[0].sections[0].content[0].data

    # Running again shouldn't double-link
    journal = add_npc_links(journal, actors)
    assert journal.chapters[0].sections[0].content[0].data.count("@UUID") == 1
```

### Integration Tests

```python
def test_full_pipeline():
    """Test complete XML → XMLDocument → Journal → HTML workflow"""
    # 1. Load real XML
    xml_path = "output/runs/test/documents/01_Introduction.xml"
    xml_string = Path(xml_path).read_text()

    # 2. Parse to XMLDocument
    doc = XMLDocument.from_xml(xml_string)

    # 3. Create Journal
    context = GameContext(actors=load_actors(), spell_cache=load_spells(), items=[])
    journal = Journal.from_xml_document(doc, context)

    # 4. Export HTML
    html = journal.to_foundry_html(image_mapping={})

    # 5. Validate output
    assert "@UUID[Actor." in html  # Has NPC links
    assert "<h1>INTRODUCTION</h1>" in html  # Has chapter title
```

---

## Open Questions

1. **Image detection accuracy**: How well will Gemini detect images vs. decorative elements?
   - May need iterative prompt refinement
   - Consider confidence scores

2. **Link priority**: If "Fireball" appears in NPC name "Fireball the Goblin", which link wins?
   - Current: First transformation wins (order matters)
   - Alternative: Longest match wins, or allow nested links

3. **Performance**: Iterative transformations scan all content multiple times
   - May need optimization for large modules
   - Consider single-pass transformation with priority queue

4. **Version migration**: How to handle existing runs with old XML?
   - Best-effort parsing with warnings?
   - Migration script to add content IDs?

5. **Content ID stability**: If XML regenerated, content IDs change
   - Breaks image_registry references
   - Need stable IDs or re-matching logic

---

## Success Criteria

- [ ] XMLDocument can parse all existing XML files without errors
- [ ] Journal hierarchy matches semantic structure (chapters/sections)
- [ ] Image placeholders preserved in content stream
- [ ] Link functions don't create nested/conflicting links
- [ ] Export to FoundryVTT HTML maintains all features
- [ ] Performance: <5s to parse + transform typical chapter
- [ ] Existing pipeline continues working during migration

---

## References

- **Current Code**:
  - `src/pdf_processing/pdf_to_xml.py` - XML generation
  - `src/pdf_processing/valid_xml_tags.py` - Approved tags
  - `src/actors/parse_stat_blocks.py` - Stat block parsing
  - `src/foundry/upload_to_foundry.py` - FoundryVTT upload

- **Example XML**:
  - `output/runs/20251022_180524/documents/01_Introduction.xml`
  - `output/runs/20250906_224058/documents/06_Conclusion.xml`

- **Related Plans**:
  - `docs/plans/2025-10-26-image-asset-extraction.md` - Map extraction
  - `docs/plans/2025-10-23-scene-extraction-and-artwork.md` - Scene artwork
  - `docs/plans/2025-10-23-actor-npc-extraction.md` - Actor extraction
